import os
import json
from unittest.mock import patch
from kopipasta.prompt import generate_prompt_template, DEFAULT_TEMPLATE


@patch("kopipasta.prompt.load_template")
@patch("kopipasta.prompt.get_project_structure")
@patch("kopipasta.prompt.read_file_contents")
@patch("kopipasta.prompt.get_file_snippet")
@patch("kopipasta.prompt.get_language_for_file")
def test_generate_prompt_template_regression(
    mock_get_lang,
    mock_get_snippet,
    mock_read_file,
    mock_get_structure,
    mock_load_template,
):
    """
    Regression test to ensure the prompt generated by Jinja2 matches the
    original hardcoded string construction, or adheres to the expected structure.
    """
    # Mock return values to ensure deterministic output
    mock_get_structure.return_value = "|-- root\n    |-- file.py"
    mock_read_file.return_value = "print('hello world')"
    mock_get_snippet.return_value = "print('snippet')"
    mock_get_lang.return_value = "python"

    from jinja2 import Template

    mock_load_template.return_value = Template(
        DEFAULT_TEMPLATE, keep_trailing_newline=True
    )

    # Define inputs
    files_to_include = [
        ("file.py", False, None, "python"),  # Full file
        ("large.py", True, None, "python"),  # Snippet
        ("patched.py", False, ["line 1", "line 2"], "python"),  # Patches
    ]
    ignore_patterns = []
    web_contents = {
        "http://example.com": (
            ("http://example.com", False, None, "html"),
            "<html>web</html>",
        )
    }
    env_vars = {}  # Empty to avoid interaction
    search_paths = ["."]

    # Execute
    result, cursor_pos = generate_prompt_template(
        files_to_include, ignore_patterns, web_contents, env_vars, search_paths
    )

    # Expected Output Construction (matches the original logic)
    expected_parts = [
        "# Project Overview\n\n",
        "## Project Structure\n\n",
        "```json\n",
        "|-- root\n",
        "    |-- file.py\n",
        "```\n\n",
        "## File Contents\n\n",
        "# FILE: file.py\n",
        "```python\n",
        "print('hello world')\n",
        "```\n\n",
        "# FILE: large.py (snippet)\n",
        "```python\n",
        "print('snippet')\n",
        "```\n\n",
        "# FILE: patched.py (selected patches)\n",
        "```python\n",
        "line 1\n",
        "line 2\n",
        "```\n\n",
        "## Web Content\n\n",
        "### http://example.com\n\n",
        "```\n",
        "<html>web</html>\n",
        "```\n\n",
        "## Task Instructions\n\n",
        # CURSOR POSITION HERE
        "\n\n",
        "## Instructions for Achieving the Task\n\n",
        "### üß† Core Philosophy\n",
        "1. **No Hallucinations**: You see the ## Project Structure. If you need to read a file that isn't in ## File Contents, stop and ask me to paste it.\n",
        "2. **Critical Partner**: Do not blindly follow instructions if they are flawed. Challenge assumptions. Propose better architectural solutions.\n",
        "3. **Hard Stops**: If you need user input, end with [AWAITING USER RESPONSE]. Do not guess.\n\n",
        "### üõ†Ô∏è Code Output & Patching (CRITICAL)\n",
        "I use a local tool to auto-apply your code blocks. You MUST follow these rules:\n\n",
        "**Rule 1: File Headers**\n",
        "Every code block must start with a comment line specifying the file path.\n",
        "Example: `// FILE: src/utils.py` or `# FILE: config.toml`\n\n",
        "**Rule 2: Modification vs. Creation**\n",
        "- **To EDIT an existing file**: Use **Unified Diff** format (with `@@ ... @@` headers). \n",
        "- **To CREATE or OVERWRITE a file**: Provide the **FULL** file content.\n",
        "- **To DELETE a file**: Output a code block containing exactly `<<<DELETE>>>`.\n\n",
        "**Rule 3: The Reset Marker**\n",
        "If you realize you made a mistake earlier in your response, output `<<<RESET>>>` on a new line. My tool will ignore everything before that marker and only process patches following it.\n\n",
        "### üöÄ Workflow\n",
        "1. **Analyze**: Briefly restate the goal. **Assess the Context**: Identify missing files OR irrelevant files that clutter the context. If I provided too much, list exactly which files to keep for the next run. **Ask to confirm.** End with [AWAITING USER RESPONSE].\n",
        "2. **Plan & Execute**: ONCE CONFIRMED, outline your approach and provide the code blocks (Diffs or Full Files).\n",
        "3. **Verify**: Suggest a command to test the changes.\n",
    ]

    expected_output = "".join(expected_parts)

    # Verify content match
    assert result == expected_output

    # Verify cursor position logic
    # The text inserted at cursor_pos should be surrounded by "## Task Instructions\n\n" and "\n\n## Instructions..."
    before_cursor = result[:cursor_pos]
    after_cursor = result[cursor_pos:]

    assert before_cursor.endswith("## Task Instructions\n\n")
    assert after_cursor.startswith("\n\n## Instructions for Achieving the Task")


def test_generate_extension_prompt(tmp_path):
    import os
    from kopipasta.prompt import generate_extension_prompt

    f1 = tmp_path / "new_logic.py"
    f1.write_text("def added(): pass")

    # FileTuple: (path, is_snippet, chunks, content_type)
    files = [(str(f1), False, None, "python")]

    # Change CWD to tmp_path so relpath returns expected short name
    old_cwd = os.getcwd()
    os.chdir(tmp_path)
    try:
        prompt = generate_extension_prompt(files, {})
    finally:
        os.chdir(old_cwd)

    assert "Here are the additional files you requested:" in prompt
    assert "# FILE: new_logic.py" in prompt
    assert "def added(): pass" in prompt
    assert "```python" in prompt


def test_get_project_structure_returns_json(tmp_path):
    """get_project_structure returns a minified JSON string with symbol lists."""
    from kopipasta.prompt import get_project_structure

    (tmp_path / "main.py").write_text("def main(): pass\n")
    (tmp_path / "sub").mkdir()
    (tmp_path / "sub" / "util.py").write_text("class Util: pass\n")
    (tmp_path / "notes.md").write_text("# Notes")

    old_cwd = os.getcwd()
    os.chdir(tmp_path)
    try:
        result = get_project_structure([])
    finally:
        os.chdir(old_cwd)

    parsed = json.loads(result)
    assert "main.py" in parsed
    assert parsed["main.py"] == ["def main"]
    assert "sub" in parsed
    assert "util.py" in parsed["sub"]
    assert parsed["sub"]["util.py"] == ["class Util"]
    assert "notes.md" in parsed
    assert parsed["notes.md"] == []  # Non-Python file has no symbols


@patch("kopipasta.prompt.load_template")
def test_generate_prompt_template_with_map_files(mock_load_template, tmp_path):
    """MAP files are included in File Contents as skeletonized content."""
    from jinja2 import Template
    from kopipasta.prompt import DEFAULT_TEMPLATE

    py_file = tmp_path / "service.py"
    py_file.write_text("class Service:\n    def run(self):\n        return 'running'\n")

    mock_load_template.return_value = Template(
        DEFAULT_TEMPLATE, keep_trailing_newline=True
    )

    mock_load_template.return_value = Template(
        DEFAULT_TEMPLATE, keep_trailing_newline=True
    )

    old_cwd = os.getcwd()
    os.chdir(tmp_path)
    try:
        result, _ = generate_prompt_template(
            files_to_include=[],
            ignore_patterns=[],
            web_contents={},
            env_vars={},
            search_paths=["."],
            map_files=[str(py_file)],
        )
    finally:
        os.chdir(old_cwd)

    assert "# FILE: service.py (map)" in result
    assert "class Service:" in result
    assert "def run(self):" in result
    assert "return 'running'" not in result  # Body stripped by skeletonize
    assert "..." in result
