import pytest
from unittest.mock import patch
from kopipasta.prompt import generate_prompt_template, DEFAULT_TEMPLATE

@patch("kopipasta.prompt.load_template")
@patch("kopipasta.prompt.get_project_structure")
@patch("kopipasta.prompt.read_file_contents")
@patch("kopipasta.prompt.get_file_snippet")
@patch("kopipasta.prompt.get_language_for_file")
def test_generate_prompt_template_regression(
    mock_get_lang, mock_get_snippet, mock_read_file, mock_get_structure, mock_load_template
):
    """
    Regression test to ensure the prompt generated by Jinja2 matches the
    original hardcoded string construction, or adheres to the expected structure.
    """
    # Mock return values to ensure deterministic output
    mock_get_structure.return_value = "|-- root\n    |-- file.py"
    mock_read_file.return_value = "print('hello world')"
    mock_get_snippet.return_value = "print('snippet')"
    mock_get_lang.return_value = "python"

    from jinja2 import Template
    mock_load_template.return_value = Template(DEFAULT_TEMPLATE, keep_trailing_newline=True)

    # Define inputs
    files_to_include = [
        ("file.py", False, None, "python"),  # Full file
        ("large.py", True, None, "python"),  # Snippet
        ("patched.py", False, ["line 1", "line 2"], "python"), # Patches
    ]
    ignore_patterns = []
    web_contents = {
        "http://example.com": (("http://example.com", False, None, "html"), "<html>web</html>")
    }
    env_vars = {} # Empty to avoid interaction
    search_paths = ["."]

    # Execute
    result, cursor_pos = generate_prompt_template(
        files_to_include, ignore_patterns, web_contents, env_vars, search_paths
    )

    # Expected Output Construction (matches the original logic)
    expected_parts = [
        "# Project Overview\n\n",
        "## Project Structure\n\n",
        "```\n",
        "|-- root\n",
        "    |-- file.py\n",
        "```\n\n",
        "## File Contents\n\n",
        "### file.py\n\n",
        "```python\n",
        "print('hello world')\n",
        "```\n\n",
        "### large.py (snippet)\n\n",
        "```python\n",
        "print('snippet')\n",
        "```\n\n",
        "### patched.py (selected patches)\n\n",
        "```python\n",
        "line 1\n",
        "line 2\n",
        "```\n\n",
        "## Web Content\n\n",
        "### http://example.com\n\n",
        # CORRECTION: Existing code clears language for HTML web content, defaulting to empty.
        "```\n", 
        "<html>web</html>\n",
        "```\n\n",
        "## Task Instructions\n\n",
        # CURSOR POSITION HERE
        "\n\n",
        "## Instructions for Achieving the Task\n\n",
        "### üß† Core Philosophy\n",
        "1. **No Hallucinations**: You see the ## Project Structure. If you need to read a file that isn't in ## File Contents, stop and ask me to paste it.\n",
        "2. **Critical Partner**: Do not blindly follow instructions if they are flawed. Challenge assumptions. Propose better architectural solutions.\n",
        "3. **Hard Stops**: If you need user input, end with [AWAITING USER RESPONSE]. Do not guess.\n\n",
        "### üõ†Ô∏è Code Output & Patching (CRITICAL)\n",
        "I use a local tool to auto-apply your code blocks. You MUST follow these rules or I will lose data:\n\n",
        "**Rule 1: File Headers**\n",
        "Every code block must start with a comment line specifying the file path.\n",
        "Example: `// FILE: src/utils.py` or `# FILE: config.toml`\n\n",
        "**Rule 2: Modification vs. Creation**\n",
        "- **To EDIT an existing file**: You MUST use **Unified Diff** format (with `@@ ... @@` headers). Do NOT post snippets without diff headers, or my tool will overwrite the whole file with just the snippet.\n",
        "- **To CREATE or OVERWRITE a file**: Provide the **FULL** file content. Do not use lazy comments like `// ... rest of code ...` inside the block.\n",
        "- **To DELETE a file**: Output a code block containing exactly `<<<DELETE>>>`.\n\n",
        "### üöÄ Workflow\n",
        "1. **Analyze**: Briefly restate the goal. **Assess the Context**: Identify missing files OR irrelevant files that clutter the context. If I provided too much, list exactly which files to keep for the next run. **Ask to confirm.** End with [AWAITING USER RESPONSE].\n",
        "2. **Plan & Execute**: ONCE CONFIRMED, outline your approach and provide the code blocks (Diffs or Full Files).\n",
        "3. **Verify**: Suggest a command to test the changes.\n"
    ]
    
    expected_output = "".join(expected_parts)

    # Verify content match
    assert result == expected_output

    # Verify cursor position logic
    # The text inserted at cursor_pos should be surrounded by "## Task Instructions\n\n" and "\n\n## Instructions..."
    before_cursor = result[:cursor_pos]
    after_cursor = result[cursor_pos:]
    
    assert before_cursor.endswith("## Task Instructions\n\n")
    assert after_cursor.startswith("\n\n## Instructions for Achieving the Task")